<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Minimalists – Codebase Breakdown</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" />
    <style>
        :root {
            --bg: #121212;
            --bg-alt: #1e1e1e;
            --text: #e0e0e0;
            --accent: #ffa500;
            --border: #333;
        }
        body {
            font-family: 'Roboto', sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.7;
            margin: 0;
            padding-bottom: 4rem;
        }
        a { color: var(--accent); }
        header {
            background: #1a1a1a;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
        }
        header a {
            color: #fff;
            text-decoration: none;
            font-weight: 600;
        }
        main { max-width: 900px; margin: 2rem auto; padding: 0 1rem; }
        h1 { font-size: 2rem; margin-bottom: 0.5rem; }
        section { margin-top: 2rem; }
        h2 { border-bottom: 2px solid var(--border); padding-bottom: 0.5rem; }
        table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
        th, td { border: 1px solid var(--border); padding: 0.75rem; text-align: left; }
        th { background: var(--bg-alt); }
        tr:nth-child(even) { background: #1b1b1b; }
        details { margin-top: 1rem; }
        details summary {
            cursor: pointer;
            font-weight: bold;
            background: var(--bg-alt);
            padding: 0.5rem;
            border-radius: 4px;
        }
        pre {
            background: var(--bg-alt);
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
        }
        img {
            width: 100%;
            max-width: 800px;
            border: 1px solid var(--border);
            border-radius: 4px;
        }
    </style>
</head>
<body>
<header><a href="index.html">← Back to Portfolio</a></header>
<main>
    <h1>Minimalists – AI & Node Control</h1>
    <p class="overview">A minimalist real-time strategy prototype where houses, turrets and helipads collaborate through dynamic node control and streamlined AI. Built with Unity and data-driven ScriptableObjects to stay highly moddable and fast.</p>

    <section id="architecture">
        <h2>Architecture</h2>
        <p>Core systems are divided between client input, game loop and combat/economy services.</p>
        <img src="docs/diagrams/minimalists-architecture.svg" alt="Architecture diagram" />
        <h3>Unit Command Sequence</h3>
        <img src="docs/diagrams/minimalists-sequence.svg" alt="Sequence diagram" />
    </section>

    <section id="data-model">
        <h2>Data Model</h2>
        <table>
            <tr><th>Field</th><th>Type</th><th>Description</th></tr>
            <tr><td>constructName</td><td>string</td><td>Display name of the structure</td></tr>
            <tr><td>upgradeCost</td><td>int</td><td>Units required to upgrade</td></tr>
            <tr><td>maxUnitCapacity</td><td>int</td><td>Population provided by this construct</td></tr>
            <tr><td>unitsPerSecond</td><td>float</td><td>Passive unit generation rate</td></tr>
        </table>
        <p>The game leans on data-driven ScriptableObjects so designers can tune balance without touching code.</p>
    </section>

    <section id="apis">
        <h2>Key APIs / Contracts</h2>
        <pre><code class="language-csharp">public class GameManager : MonoBehaviour
{
    public void registerUnit(UnitController unit);
    public void unregisterUnit(UnitController unit);
}</code></pre>
        <pre><code class="language-csharp">public static class AStarPathfinder
{
    public static List&lt;Vector3&gt; FindPath(Vector3 startPosition, Vector3 endPosition,
        IEnumerable&lt;Transform&gt; obstacles, float agentRadius);
}</code></pre>
        <pre><code class="language-csharp">public class ConstructController : MonoBehaviour
{
    public void SendUnits(ConstructController target, float percentage);
}</code></pre>
    </section>

    <section id="snippets">
        <h2>Representative Code Snippets</h2>
        <p><strong>Map analysis assigns roles to each node</strong> – uses distance percentages to classify frontline, support and economic nodes.</p>
        <details>
            <summary>Show code</summary>
            <pre><code class="language-csharp">@AIManager7.cs lines 66-103
private void AnalyzeMapAndAssignRoles(List&lt;ConstructController&gt; myNodes)
{
    nodeRoles.Clear();
    var enemyNodes = GameManager.Instance.allConstructs
        .Where(c =&gt; c.Owner != aiFaction && c.Owner != GameManager.Instance.unclaimedFaction)
        .ToList();

    // If no enemies exist or we have too few nodes for complex roles, they are all economic.
    if (!enemyNodes.Any() || myNodes.Count &lt;= 2)
    {
        myNodes.ForEach(n =&gt; nodeRoles[n] = NodeRole.Economic);
        return;
    }

    Vector3 enemyCenter = GetFactionCenter(enemyNodes);

    // Sort nodes by their distance to the enemy's center of mass.
    var sortedNodes = myNodes.OrderBy(n =&gt; Vector3.Distance(n.transform.position, enemyCenter)).ToList();

    int nodeCount = sortedNodes.Count;
    // Designate roles by percentage: closest 30% are Frontline, next 40% are Support, rest are Economic.
    int frontlineCount = Mathf.Max(1, Mathf.CeilToInt(nodeCount * 0.3f));
    int supportCount = Mathf.CeilToInt(nodeCount * 0.4f);

    for (int i = 0; i &lt; nodeCount; i++)
    {
        ConstructController currentNode = sortedNodes[i];
        if (i &lt; frontlineCount)
        {
            nodeRoles[currentNode] = NodeRole.Frontline;
        }
        else if (i &lt; frontlineCount + supportCount)
        {
            nodeRoles[currentNode] = NodeRole.Support;
        }
        else
        {
            nodeRoles[currentNode] = NodeRole.Economic;
        }
    }
}</code></pre>
        </details>
        <p><a href="https://github.com/OliverNealDev/Minimalists/blob/main/Assets/Scripts/AIManager7.cs#L66-L103" target="_blank">View on GitHub (lines 66–103)</a></p>

        <p><strong>A* pathfinder core loop</strong> – processes open and closed sets with line‑of‑sight shortcut.</p>
        <details>
            <summary>Show code</summary>
            <pre><code class="language-csharp">@AStarPathfinder.cs lines 30-70
openSet.Add(startNode);

while (openSet.Count &gt; 0)
{
    PathNode currentNode = openSet[0];
    for (int i = 1; i &lt; openSet.Count; i++)
    {
        if (openSet[i].FCost &lt; currentNode.FCost || (openSet[i].FCost == currentNode.FCost &amp;&amp; openSet[i].HCost &lt; currentNode.HCost))
        {
            currentNode = openSet[i];
        }
    }

    openSet.Remove(currentNode);
    closedSet.Add(currentNode);

    if (HasClearLineOfSight(currentNode.Position, endNode.Position, allObstacles, agentRadius))
    {
        endNode.Parent = currentNode;
        return RetracePath(startNode, endNode);
    }

    foreach (var neighborNode in GetNeighbors(currentNode, allObstacles, agentRadius))
    {
        if (closedSet.Any(n =&gt; n.Position == neighborNode.Position))
        {
            continue;
        }

        float newMovementCostToNeighbor = currentNode.GCost + Vector3.Distance(currentNode.Position, neighborNode.Position);

        var existingOpenNode = openSet.FirstOrDefault(n =&gt; n.Position == neighborNode.Position);
        if (existingOpenNode == null || newMovementCostToNeighbor &lt; existingOpenNode.GCost)
        {
            neighborNode.GCost = newMovementCostToNeighbor;
            neighborNode.HCost = Vector3.Distance(neighborNode.Position, endNode.Position);
            neighborNode.Parent = currentNode;

            if (existingOpenNode == null)
            {
                openSet.Add(neighborNode);
            }
        }
    }
}</code></pre>
        </details>
        <p><a href="https://github.com/OliverNealDev/Minimalists/blob/main/Assets/Scripts/AStarPathfinder.cs#L30-L70" target="_blank">View on GitHub (lines 30–70)</a></p>

        <p><strong>Streaming units between nodes</strong> – validates targets and spawns units along the navmesh.</p>
        <details>
            <summary>Show code</summary>
            <pre><code class="language-csharp">@ConstructController.cs lines 415-450
public void SendUnits(ConstructController target, float percentage)
{
    bool isValidTarget = true;
    foreach (ConstructController construct in targetConstructs)
    {
        if (construct == target)
        {
            isValidTarget = false;
            break;
        }
    }

    if (!isValidTarget) return;

    int unitsToSend = Mathf.FloorToInt(UnitCount * percentage);
    if (unitsToSend == 0 &amp;&amp; UnitCount &gt; 0)
    {
        unitsToSend = 1;
    }
    if (unitsToSend &gt; 0)
    {
        if (currentConstructData is HelipadData)
        {
            targetConstructs.Add(target);
            StartCoroutine(SpawnUnitsRoutine(unitsToSend, target));
        }
        else
        {
            if (navmeshIndex == target.navmeshIndex)
            {
                targetConstructs.Add(target);
                StartCoroutine(SpawnUnitsRoutine(unitsToSend, target));
            }
        }
    }
}</code></pre>
        </details>
        <p><a href="https://github.com/OliverNealDev/Minimalists/blob/main/Assets/Scripts/ConstructController.cs#L415-L450" target="_blank">View on GitHub (lines 415–450)</a></p>
    </section>

    <section id="performance">
        <h2>Performance Notes</h2>
        <p>Profiling is ongoing and formal benchmarks are not yet published.</p>
    </section>

    <section id="testing">
        <h2>Testing & Validation</h2>
        <p>Currently verified through manual playtesting; no automated tests are in place.</p>
    </section>

    <section id="tradeoffs">
        <h2>Trade-offs & Next Steps</h2>
        <ul>
            <li>Finite state AI is easy to reason about; behavior trees could scale variety later.</li>
            <li>Custom pathfinder avoids heavy NavMesh but lacks dynamic obstacle support.</li>
            <li>Data-driven design simplifies tuning yet requires editor diligence to avoid invalid combos.</li>
        </ul>
    </section>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js"></script>
</body>
</html>
